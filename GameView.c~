////////////////////////////////////////////////////////////////////////
// COMP2521 20T2 ... the Fury of Dracula
// GameView.c: GameView ADT implementation
//
// 2014-07-01	v1.0	Team Dracula <cs2521@cse.unsw.edu.au>
// 2017-12-01	v1.1	Team Dracula <cs2521@cse.unsw.edu.au>
// 2018-12-31	v2.0	Team Dracula <cs2521@cse.unsw.edu.au>
// 2020-07-10   v3.0    Team Dracula <cs2521@cse.unsw.edu.au>
//
////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Game.h"
#include "GameView.h"
#include "Map.h"
#include "Places.h"
#include "testUtils.h"
<<<<<<< HEAD
// add your own #includes here
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

#define NUM_HUNTERS 4

<<<<<<< HEAD
/*typedef struct city *City;

typedef struct city {
	PlaceId cityID;
	int trap_num;
} city;*/

typedef int Item;
typedef struct QueueRep *Queue;

static void trapEncountered(GameView new, int placeID, int playerIndex);
static void draculaEncounter(GameView new, int playerIndex);
//static void hunterReachableRecursive(ConnList head, PlaceId *hunterReachable, Map new, int railLength, int j);
static ConnList createNode (Item item);
Queue createQueue (void);
void dropQueue (Queue q);
void enterQueue (Queue q, Item it);
Item leaveQueue (Queue q);


struct QueueRep {
	ConnList head;
	ConnList tail;
	int size;
};

struct gameView {
	// TODO: ADD FIELDS HERE

	int player_hp[5]; // player_hp[0] = LG's health point
					// player_hp[1] = DS's health point
					// player_hp[2] = VH's health point
					// player_hp[3] = MH's health point
					// player_hp[4] = Dracula's health point

	Round round; // which round it is
	int city_with_vam; // the city ID with unmatured vampire, if not, set value = -1
	//City cities_with_trap[TRAIL_SIZE];
	int *trapLocations; // int array of trap locations
	//array of cities with may include traps;if empty, set value = -1
	int score; // score of game
	int inhospital[4]; // dracula cannot be in hosptial.not in hosptial is 0, in hosptial = 1 (0 1 2 3)
	int **past_route; // store the past route for each player
	char *message[100]; // store messages for each round.
	int playerPlace[5]; // PlaceId of the current Player
	//Player currPlayer;
	int turn;
	int trail[366]; // The trail of Dracula
=======
typedef int Item;
typedef struct QueueRep *Queue;

static void trapEncountered(GameView new, int placeID, int playerIndex);
static void draculaEncounter(GameView new, int playerIndex);
static ConnList createNode(Item item);
Queue createQueue(void);
void dropQueue(Queue q);
void enterQueue(Queue q, Item it);
Item leaveQueue(Queue q);


struct QueueRep {
	ConnList head;
	ConnList tail;
};

struct gameView {

	int player_hp[5];    // player_hp[0] = LG's health point
					     // player_hp[1] = DS's health point
					     // player_hp[2] = VH's health point
					     // player_hp[3] = MH's health point
					     // player_hp[4] = Dracula's health point

	Round round;         // Which round it is
	int city_with_vam;   // the city ID with unmatured vampire, if not, set value = -1
	int *trapLocations;  // int array of trap locations
	                     //array of cities with may include traps;if empty, set value = -1
	int score;           // score of game
	int inhospital[4];   // dracula cannot be in hosptial.not in hosptial is 0, in hosptial = 1 (0 1 2 3)
	int **past_route;    // store the past route for each player
	char **message;      // store messages for each turn.
	int playerPlace[5];  // PlaceId of the current Player
	int turn;            // The number of turns
	int trail[366];      // The trail of Dracula
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
};



////////////////////////////////////////////////////////////////////////
// Constructor/Destructor

GameView GvNew(char *pastPlays, Message messages[])
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
	
	
	
=======
    // Initialise the gameview struct
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	GameView new = malloc(sizeof(*new));
	if (new == NULL) {
		fprintf(stderr, "Couldn't allocate GameView!\n");
		exit(EXIT_FAILURE);
	}
<<<<<<< HEAD

	
	int i = 0;
	
=======
	
	// Covert the pointer pastPlays to an char array
	int i = 0;
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	int length = strlen(pastPlays);
	char str[length];
	for (i = 0; pastPlays[i] != '\0'; i++) {
	    str[i] = pastPlays[i];
	}
	
<<<<<<< HEAD
	i = 0;
	while (i <= 3) {
	    new->player_hp[i] = 9;
	    i++;
	}
	new->player_hp[i] = 40;
	
	new->round = 0;
	new->city_with_vam = NOWHERE;
	
=======
	// Initialise each player's life points
	i = 0;
	while (i < NUM_HUNTERS) {
	    new->player_hp[i] = GAME_START_HUNTER_LIFE_POINTS;
	    i++;
	}
	new->player_hp[i] = GAME_START_BLOOD_POINTS;
	
	// Initialise round number and city_with_vam
	new->round = 0;
	new->city_with_vam = NOWHERE;
	
	// Initialise trapLocations to NOWHERE
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	new->trapLocations = malloc(6 * sizeof(int));
	for (i = 0; i < 6; i++) {
	    new->trapLocations[i] = NOWHERE;
	}
	
<<<<<<< HEAD
	
	new->score = 366;
	
	for (i = 0; i < 4; i++) {
	    new->inhospital[i] = 0;
	}

=======
	// Initialise game score
	new->score = GAME_START_SCORE;
	
	// All hunters are not in the hospital at the start of the game
	for (i = 0; i < NUM_HUNTERS; i++) {
	    new->inhospital[i] = 0;
	}

    // Initialise the past route of all players to NOWHERE
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	new->past_route = malloc(5 *sizeof(int *));
    for (i = 0; i < 5; i++) {
        new->past_route[i] = malloc(366 * sizeof(int));
        for (int j = 0; j < 366; j++) {
            new->past_route[i][j] = NOWHERE;
        } 
<<<<<<< HEAD
    }	
=======
    }
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
    
    // Copy the messages to gv->messages
    int totalMsg = 0;
    new->message = malloc(sizeof(char *) * 366);
    for (i = 0; i < 366; i++) {
        new->message[i] = NULL;
    }
    
<<<<<<< HEAD

     // not sure
    for (i = 0; i < new->round; i++) {
        new->message[i] = malloc(1024 * sizeof(char));
    }
=======
    // While the first character of the message is printable
    while (messages[totalMsg][0] >= '!' && messages[totalMsg][0] <= '~') {
        i = 0;
        while (messages[totalMsg][i] != '\0') {
            i++;
        }
        
        if (i < 100) {
            new->message[totalMsg] = strdup(messages[totalMsg]);
            totalMsg++;
        }
    }
    
	
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	
	// Initialise every place each player passed
	for(i = 0; i < 5; i++) new->playerPlace[i] = NOWHERE;
	
	for (i = 0; i < 366; i++) new->trail[i] = NOWHERE;

	new->turn = 0;
<<<<<<< HEAD
=======
	
	// Extract each turn out from pastPlays
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	char *step = strtok(str, " ");
	while (step != NULL) {

	    int is_DOUBLE_BACK_HIDE = 0;
	    
	    // If the hunter is in hospital, regain their full life points
	    for (i = 0; i < 4; i++) {
	        if (new->inhospital[i] == 1)
	            new->player_hp[i] = GAME_START_HUNTER_LIFE_POINTS;
	    }
<<<<<<< HEAD
	    new->turn++;    
=======
	    
	    new->turn++;  
	    
	    // Extract the placeId from each turn  
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
		char place[3];
		for(i = 1; i <= 2; i++) {
		    place[i - 1] = step[i];
	    }
	    
	    place[2] = '\0';
	    
	    // Store the placeId
		int placeID = -1;
		if (place[0] == 'S' && place[1] == '?') {
		    placeID = SEA_UNKNOWN;
		} else if (place[0] == 'C' && place[1] == '?') {
		    placeID = CITY_UNKNOWN;
		} else {
		    placeID = placeAbbrevToId(place);
		}
<<<<<<< HEAD

=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

		// Store the curr position of each player
		int playerIndex = 0;
		if (step[0] == 'G') {
			new->playerPlace[PLAYER_LORD_GODALMING] = placeID;
			playerIndex = PLAYER_LORD_GODALMING;
		} else if (step[0] == 'S') {
			new->playerPlace[PLAYER_DR_SEWARD] = placeID;
			playerIndex = PLAYER_DR_SEWARD;
		} else if (step[0] == 'H') {
			new->playerPlace[PLAYER_VAN_HELSING] = placeID;
			playerIndex = PLAYER_VAN_HELSING;
		} else if (step[0] == 'M') {
			new->playerPlace[PLAYER_MINA_HARKER] = placeID;
			playerIndex = PLAYER_MINA_HARKER;
		} else if (step[0] == 'D') {
<<<<<<< HEAD
=======
		
		    // Add current place to dracula's trail
		    i = 0;
		    while (new->trail[i] != NOWHERE) {
		        i++;
		    }
		    new->trail[i] = placeID;
		    
		    // Store the real placeId if dracula ever used DB or HIDE
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
		    i = 0;
		    while (new->trail[i] != NOWHERE) {
		        i++;
		    }
		    new->trail[i] = placeID;
		    i = 0;
		    while (new->trail[i] != NOWHERE) {
		        i++;
		    } // i = trail size
		    if (placeID >= DOUBLE_BACK_1  && placeID <= DOUBLE_BACK_5) {
			    is_DOUBLE_BACK_HIDE = placeID;
<<<<<<< HEAD
		        int trackBack = placeID % 103;
=======
		        int trackBack = placeID % DOUBLE_BACK_1;
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

	            placeID = new->trail[i - 2 - trackBack];
		        
		    } else if (placeID == HIDE) {
		        is_DOUBLE_BACK_HIDE = placeID;
		        placeID = new->trail[i - 2];

		    }
			new->playerPlace[PLAYER_DRACULA] = placeID;
		    new->trail[i - 1] = placeID;
			playerIndex = PLAYER_DRACULA;
			
			// Increase dracula's life point by 10
		    if (placeID == CASTLE_DRACULA) {
		        new->player_hp[playerIndex] += 10;
	        }
		}
		
		
		// Store DB or HIDE info in array past_route
        i = 0;
        while (new->past_route[playerIndex][i] != NOWHERE) {
            i++;
        }
        if (is_DOUBLE_BACK_HIDE != 0) {
            new->past_route[playerIndex][i] = is_DOUBLE_BACK_HIDE;
        } else {
            new->past_route[playerIndex][i] = placeID;
        }


		
<<<<<<< HEAD
		// If hunters
=======
		// If the current player is a hunter
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
		if (step[0] != 'D') {
		
			// Encounter surprises
			if (step[3] == 'T') {
				trapEncountered(new, placeID, playerIndex);
			} else if (step[3] == 'V') {
			    new->city_with_vam = NOWHERE;
			} else if (step[3] == 'D') {
			    draculaEncounter(new, playerIndex);
			}
<<<<<<< HEAD
			    
			
			// Vampire
=======


>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
			if (new->inhospital[playerIndex] == 0 && step[4] == 'T') {
			    trapEncountered(new, placeID, playerIndex);
			} else if (new->inhospital[playerIndex] == 0 && step[4] == 'V') {
				new->city_with_vam = NOWHERE;
			} else if (new->inhospital[playerIndex] == 0 && step[4] == 'D') {
			    draculaEncounter(new, playerIndex);
			}
			
			
			if (new->inhospital[playerIndex] == 0 && step[5] == 'T') {
			    trapEncountered(new, placeID, playerIndex);
			} else if (new->inhospital[playerIndex] == 0 && step[5] == 'V') {
				new->city_with_vam = NOWHERE;
			} else if (new->inhospital[playerIndex] == 0 && step[5] == 'D') {
			    draculaEncounter(new, playerIndex);
			}
<<<<<<< HEAD
=======
			
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
			if (new->inhospital[playerIndex] == 0 && step[6] == 'D') {
			    draculaEncounter(new, playerIndex);
			}
			
			
		} else {
		    // If the current player is dracula
		    
		    // If dracula is at sea
		    if (step[2] == '?') {
		        if (step[1] == 'S') {
		            new->player_hp[playerIndex] -= LIFE_LOSS_SEA;
		        }
		    } else if (placeIdToType(placeID) == SEA) {
		        new->player_hp[playerIndex] -= LIFE_LOSS_SEA;
		    }
		    
			// If a trap left the trail
			int index = 1;
			while (index < 6) {
				new->trapLocations[index - 1] = new->trapLocations[index];
				index++;
			}
			new->trapLocations[index - 1] = NOWHERE;

			// If place a trap
			if (step[3] == 'T') {
				new->trapLocations[5] = placeID;
			}

			// If place a vampire
			if (step[4] == 'V') {
				new->city_with_vam = placeID;
			} 

			// If a vampire matures
			if (step[5] == 'V') {
				new->city_with_vam = NOWHERE;
				new->score -= 13;
			}

			new->score--;
		}

<<<<<<< HEAD
=======
        // Extract next turn
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    step = strtok(NULL, " ");
	}
	new->round = new->turn / 5;
    
	return new;
}


// Free everything malloced in GvNew
void GvFree(GameView gv)
{
    int i;
    
<<<<<<< HEAD
    
    
    
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
    for (i = 0; i < 5; i++) {
        free(gv->past_route[i]);
    }
    free(gv->past_route);
    
    free(gv->trapLocations);
<<<<<<< HEAD
	
    
    
    for (i = 0; i < gv->round; i++) {
        free(gv->message[i]);
    }
    
    
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
    
    for (i = 0; gv->message[i] != NULL && i < gv->turn; i++) {
        printf("%d  %s\n", i, gv->message[i]);
        //free(gv->message[i]);
    }
    
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	free(gv);
}

////////////////////////////////////////////////////////////////////////
// Game State Information

Round GvGetRound(GameView gv)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return gv->round;
}

Player GvGetPlayer(GameView gv)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	int value = gv->turn % 5;
	if (value == 0) {
	    return PLAYER_LORD_GODALMING;
	} else if (value == 1) {
	    return PLAYER_DR_SEWARD;
	} else if (value == 2) {
	    return PLAYER_VAN_HELSING;
	} else if (value == 3) {
	    return PLAYER_MINA_HARKER;
	} else {
	    return PLAYER_DRACULA;
	}	
}

int GvGetScore(GameView gv)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return gv->score;
}

int GvGetHealth(GameView gv, Player player)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION	
		
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return gv->player_hp[player];
}

PlaceId GvGetPlayerLocation(GameView gv, Player player)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
	
	
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return gv->playerPlace[player];
}

PlaceId GvGetVampireLocation(GameView gv)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return gv->city_with_vam;
}


PlaceId *GvGetTrapLocations(GameView gv, int *numTraps)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
    // Get the number of traps in the rail
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	int j = 0;
	for (int i = 0; i < 6;i++) {
	    if (gv->trapLocations[i] != NOWHERE) {
	        j++;
	    }
    }
<<<<<<< HEAD

=======
    
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	*numTraps = j;
	
	// Put the placeId where there is a trap into an array
	// The array traps should be freed manually
	PlaceId *traps = malloc(6 * sizeof(int));
	j = 0;
	for (int i = 0; i < 6;i++) {
	    if (gv->trapLocations[i] != NOWHERE) {
	        traps[j] = gv->trapLocations[i];
	        j++;
	    }
	}
	return traps;
}

////////////////////////////////////////////////////////////////////////
// Game History

PlaceId *GvGetMoveHistory(GameView gv, Player player,
                          int *numReturnedMoves, bool *canFree)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
	
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	*canFree = false;
	int i = 0;
	while (gv->past_route[player][i] != NOWHERE) {
	    i++;
	}
	*numReturnedMoves = i;
	return gv->past_route[player];
}

PlaceId *GvGetLastMoves(GameView gv, Player player, int numMoves,
                        int *numReturnedMoves, bool *canFree)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	int i = 0;
	PlaceId *array = malloc(numMoves * sizeof(PlaceId));
	while (gv->past_route[player][i] != NOWHERE) {
	    i++;
	}
	i--;
	int counter = 0;
<<<<<<< HEAD
	if (numMoves <= i + 1) {
=======
	
	// If the required number of moves
	// is less than the number of moves the player has made so far.
	if (numMoves <= i + 1) {
	
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    while (counter < numMoves) {
	        array[counter] = gv->past_route[player][i];
	        i--;
	        counter++;
	    }
	    *numReturnedMoves = numMoves;
	    *canFree = true;
<<<<<<< HEAD
	    printf("lastMoves: %d\n", array[0]);
	} else {
=======
	    
	} else {
	
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    *numReturnedMoves = i;
	    *canFree = false;
	    
	    array = GvGetMoveHistory(gv, player,numReturnedMoves, canFree);
	    return array;
<<<<<<< HEAD
        
    }
	    
=======
    } 
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	
	return array;
}

PlaceId *GvGetLocationHistory(GameView gv, Player player,
                              int *numReturnedLocs, bool *canFree)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	if (player == PLAYER_DRACULA) {
	    *canFree = false; 
	    int i = 0; 
	    while (gv->trail[i] != NOWHERE) {
	        i++;
        }
	    *numReturnedLocs = i;
	    return gv->trail;
	} else {
	    return GvGetMoveHistory(gv, player, numReturnedLocs, canFree);
	}
	
}

PlaceId *GvGetLastLocations(GameView gv, Player player, int numLocs,
                            int *numReturnedLocs, bool *canFree)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
	if (player == PLAYER_DRACULA) {
	    int i = 0;
	    while (gv->trail[i] != NOWHERE) {
	        i++;
	    } // array size
=======
	if (player == PLAYER_DRACULA) {
	
	    int i = 0;
	    while (gv->trail[i] != NOWHERE) {
	        i++;
	    }
	    
	    // If the required number of locations
	    // is greater than the number of locations the player has made so far.
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    if (numLocs > i) {
	        numLocs = i;
	        *canFree = false;
	        return GvGetLocationHistory(gv, player, numReturnedLocs, canFree);
	    }
<<<<<<< HEAD
        PlaceId *array = malloc(sizeof(PlaceId) * i);
        int counter = 0;
        while (counter < numLocs) {
            array[counter] = gv->trail[i - 1 - counter];
=======
	    
	    // Store the placeId into a new array
        PlaceId *draculaLastLocs = malloc(sizeof(PlaceId) * i);
        int counter = 0;
        while (counter < numLocs) {
            draculaLastLocs[counter] = gv->trail[i - 1 - counter];
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
            counter++;
        }
        *canFree = true;
        *numReturnedLocs = counter;
<<<<<<< HEAD
	    return array;
	        
	    
	} else {
	    int i = 0;
	    while (gv->past_route[player][i] != NOWHERE) {
	        i++;
	    } // array size
=======
	    return draculaLastLocs;
	    
	} else {
	
	    int i = 0;
	    while (gv->past_route[player][i] != NOWHERE) {
	        i++;
	    }
	    
	    // If the required number of locations
	    // is greater than the number of locations the player has made so far.
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    if (numLocs > i) {
	        numLocs = i;
	        *canFree = false;
	        return GvGetLocationHistory(gv, player, numReturnedLocs, canFree);
	    }
<<<<<<< HEAD
        PlaceId *array = malloc(sizeof(PlaceId) * i);
        int counter = 0;
        while (counter < numLocs) {
            array[counter] = gv->past_route[player][i - 1 - counter];
=======
	    
	    // Store the placeId into a new array
        PlaceId *hunterLastLocs = malloc(sizeof(PlaceId) * i);
        int counter = 0;
        while (counter < numLocs) {
            hunterLastLocs[counter] = gv->past_route[player][i - 1 - counter];
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
            counter++;
        }
        // not sure
        *canFree = false;
        *numReturnedLocs = counter;
<<<<<<< HEAD
	    return array;
=======
	    return hunterLastLocs;
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	}
}

////////////////////////////////////////////////////////////////////////
// Making a Move

PlaceId *GvGetReachable(GameView gv, Player player, Round round,
                        PlaceId from, int *numReturnedLocs)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
Map new = MapNew();
	ConnList head = MapGetConnections(new, from);
	int railLength = (round + player) % 4;
	
=======

    Map new = MapNew();
	ConnList head = MapGetConnections(new, from);
	int railLength = (round + player) % 4;
	
	// Allocate enough space
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	PlaceId *reachable = malloc(sizeof(PlaceId) * 1024);
	int i;
	int counter = 0;
	
<<<<<<< HEAD
	for (i = 0; i < 1024; i++) reachable[i] = NOWHERE;
	
    
 

	if (player != PLAYER_DRACULA) {
=======
	// Initialise reachable to NOWHERE
	for (i = 0; i < 1024; i++) reachable[i] = NOWHERE;
	
    // Reachable by rail
	if (player != PLAYER_DRACULA) {
	
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
        Queue place = createQueue();
        Queue index = createQueue();
        enterQueue(place, from);
        enterQueue(index, railLength);
<<<<<<< HEAD
=======
        
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    while (head != NULL) {
            while (place->head != NULL) {
                PlaceId fromplace = leaveQueue(place);
                PlaceId railcheck = leaveQueue(index);
                
<<<<<<< HEAD
=======
                // Check duplicate locations
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
                int dup = 0;
                i = 0;
                while (reachable[i] != NOWHERE) {
                    if (reachable[i] == fromplace) {
                        dup = 1;
                        break;
                    }
                    i++;
                }
<<<<<<< HEAD
                printf("railcheck: %d\n", railcheck);
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
                
                if (railcheck < 0 || dup == 1) {
                    continue;
                }
                reachable[counter] = fromplace;
                counter++;
                
<<<<<<< HEAD
                for (ConnList curr = MapGetConnections(new, fromplace); curr != NULL; curr = curr->next) {
=======
                ConnList curr = MapGetConnections(new, fromplace);
                while (curr != NULL) {
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
                    if (curr->type == RAIL) {
                        enterQueue(place, curr->p);
                        enterQueue(index, railcheck - 1);
                    }
<<<<<<< HEAD
=======
                    curr = curr->next;
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
                }
            }
            head = head->next;
        }
        dropQueue(place);
        dropQueue(index);
    }
    
    ConnList curr = MapGetConnections(new, from);
    while (curr != NULL) {
        if (curr->type == ROAD) {
<<<<<<< HEAD
           int dup = 0;
=======
            
            // Check duplicate locations
            int dup = 0;
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
            i = 0;
            while (reachable[i] != NOWHERE) {
                if (reachable[i] == curr->p) {
                    dup = 1;
                    break;
                }
                i++;
            }

<<<<<<< HEAD
            if (player == PLAYER_DRACULA && head->p == ST_JOSEPH_AND_ST_MARY) {
                curr = curr->next;
                continue;
            }
=======
            if (player == PLAYER_DRACULA && curr->p == ST_JOSEPH_AND_ST_MARY) {
                curr = curr->next;
                continue;
            }
            
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
            if (dup == 0) {
                reachable[counter] = curr->p;
                counter++;
            }

        }
        curr = curr->next;
    }
        
   
    curr = MapGetConnections(new, from);
    while (curr != NULL) {
        if (curr->type == BOAT) {
            reachable[counter] = curr->p;
            counter++;
        }
        curr = curr->next;
    }
    
    
<<<<<<< HEAD
    
    
	i = 0;
	int flag = 0;
	while (i < counter) {
	    if (reachable[i] == from) {
	        flag = 1;
	    }
	    i++;
	}
	if (flag == 0) {
=======
	i = 0;
	int currPlaceIncl = 0;
	while (i < counter) {
	    if (reachable[i] == from) {
	        currPlaceIncl = 1;
	    }
	    i++;
	}
	if (currPlaceIncl == 0) {
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	    reachable[counter] = from;
	    counter++;    
    }
	*numReturnedLocs = counter;
	return reachable;
	
	return 0;
}

PlaceId *GvGetReachableByType(GameView gv, Player player, Round round,
                              PlaceId from, bool road, bool rail,
                              bool boat, int *numReturnedLocs)
{
<<<<<<< HEAD
	// TODO: REPLACE THIS WITH YOUR OWN IMPLEMENTATION
	Map new = MapNew();
	ConnList head = MapGetConnections(new, from);
	int railLength = (round + player) % 4;
	
	PlaceId *reachable = malloc(sizeof(PlaceId) * 1024);
	int i;
	int counter = 0;
	
	for (i = 0; i < 1024; i++) reachable[i] = NOWHERE;
	
	

	if (player != PLAYER_DRACULA && rail == true) {
        Queue place = createQueue();
        Queue index = createQueue();
        enterQueue(place, from);
        enterQueue(index, railLength);
	    while (head != NULL) {
            while (place->head != NULL) {
                PlaceId fromplace = leaveQueue(place);
                PlaceId railcheck = leaveQueue(index);
                
                int dup = 0;
                i = 0;
                while (reachable[i] != NOWHERE) {
                    if (reachable[i] == fromplace) {
                        dup = 1;
                        break;
                    }
                    i++;
                }
                printf("railcheck: %d\n", railcheck);
                
                if (railcheck < 0 || dup == 1) {
                    continue;
                }
                reachable[counter] = fromplace;
                counter++;
                
                for (ConnList curr = MapGetConnections(new, fromplace); curr != NULL; curr = curr->next) {
                    if (curr->type == RAIL) {
                        enterQueue(place, curr->p);
                        enterQueue(index, railcheck - 1);
                    }
                }
            }
            head = head->next;
        }
        dropQueue(place);
        dropQueue(index);
    }
    
    if (road == true) {
        ConnList curr = head;
        while (curr != NULL) {
            if (curr->type == ROAD) {
                int dup = 0;
                i = 0;
                while (reachable[i] != NOWHERE) {
                    if (reachable[i] == curr->p) {
                        dup = 1;
                        break;
                    }
                    i++;
                }
  
                if (player == PLAYER_DRACULA && head->p == ST_JOSEPH_AND_ST_MARY) {
                    curr = curr->next;
                    continue;
                }
                if (dup == 0) {
                
                    reachable[counter] = curr->p;
                    counter++;
                }

            }
            curr = curr->next;
        }
    }
        
    if (boat == true) {
        ConnList curr = head;
        while (curr != NULL) {
            if (curr->type == BOAT) {
                reachable[counter] = curr->p;
                counter++;
            }
            curr = curr->next;
        }
    }
    
    
    
	i = 0;
	int flag = 0;
	while (i < counter) {
	    if (reachable[i] == from) {
	        flag = 1;
	    }
	    i++;
	}
	if (flag == 0) {
	    reachable[counter] = from;
	    counter++;    
    }
	*numReturnedLocs = counter;
	return reachable;
}
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

	Map new = MapNew();
	ConnList head = MapGetConnections(new, from);
	int railLength = (round + player) % 4;
	
	PlaceId *reachable = malloc(sizeof(PlaceId) * 1024);
	int i;
	int counter = 0;
	
	for (i = 0; i < 1024; i++) reachable[i] = NOWHERE;
	
	

	if (player != PLAYER_DRACULA && rail == true) {
        Queue place = createQueue();
        Queue index = createQueue();
        enterQueue(place, from);
        enterQueue(index, railLength);
	    while (head != NULL) {
            while (place->head != NULL) {
                PlaceId fromplace = leaveQueue(place);
                PlaceId railcheck = leaveQueue(index);
                
                int dup = 0;
                i = 0;
                while (reachable[i] != NOWHERE) {
                    if (reachable[i] == fromplace) {
                        dup = 1;
                        break;
                    }
                    i++;
                }
                
                if (railcheck < 0 || dup == 1) {
                    continue;
                }
                reachable[counter] = fromplace;
                counter++;
                
                for (ConnList curr = MapGetConnections(new, fromplace); curr != NULL; curr = curr->next) {
                    if (curr->type == RAIL) {
                        enterQueue(place, curr->p);
                        enterQueue(index, railcheck - 1);
                    }
                }
            }
            head = head->next;
        }
        dropQueue(place);
        dropQueue(index);
    }
    
    if (road == true) {
        ConnList curr = head;
        while (curr != NULL) {
            if (curr->type == ROAD) {
                int dup = 0;
                i = 0;
                while (reachable[i] != NOWHERE) {
                    if (reachable[i] == curr->p) {
                        dup = 1;
                        break;
                    }
                    i++;
                }
  
                if (player == PLAYER_DRACULA && curr->p == ST_JOSEPH_AND_ST_MARY) {
                    curr = curr->next;
                    continue;
                }
                if (dup == 0) {
                
                    reachable[counter] = curr->p;
                    counter++;
                }

<<<<<<< HEAD
// TODO
static void trapEncountered(GameView new, int placeID, int playerIndex) 
{
    for (int i = 0; i < TRAIL_SIZE; i++) {
		if(placeID == new->trapLocations[i] && new->trapLocations[i] != NOWHERE) {
		    
			new->player_hp[playerIndex] -= 2;
			if (new->player_hp[playerIndex] < 0) new->player_hp[playerIndex] = 0;
			new->trapLocations[i] = NOWHERE;
			// Send to the hospital
			if (new->player_hp[playerIndex] <= 0) {
				new->playerPlace[playerIndex] = ST_JOSEPH_AND_ST_MARY;
				new->inhospital[playerIndex] = 1;
				new->score -= 6;
				break;
			}
		}
	}
=======
            }
            curr = curr->next;
        }
    }
        
    if (boat == true) {
        ConnList curr = head;
        while (curr != NULL) {
            if (curr->type == BOAT) {
                reachable[counter] = curr->p;
                counter++;
            }
            curr = curr->next;
        }
    }
    
    
    
	i = 0;
	int currPlaceIncl = 0;
	while (i < counter) {
	    if (reachable[i] == from) {
	        currPlaceIncl = 1;
	    }
	    i++;
	}
	if (currPlaceIncl == 0) {
	    reachable[counter] = from;
	    counter++;    
    }
	*numReturnedLocs = counter;
	return reachable;
}
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

////////////////////////////////////////////////////////////////////////
////////////////////  Helper Function  /////////////////////////////////
////////////////////////////////////////////////////////////////////////

// If a hunter encountered a trap, deduct the corresponding life points
static void trapEncountered(GameView new, int placeID, int playerIndex) 
{
    for (int i = 0; i < TRAIL_SIZE; i++) {
		if(placeID == new->trapLocations[i] && new->trapLocations[i] != NOWHERE) {
		    
			new->player_hp[playerIndex] -= 2;
			if (new->player_hp[playerIndex] < 0) {
			    new->player_hp[playerIndex] = 0;
		    }
			new->trapLocations[i] = NOWHERE;
			
			// Send to the hospital
			if (new->player_hp[playerIndex] <= 0) {
				new->playerPlace[playerIndex] = ST_JOSEPH_AND_ST_MARY;
				new->inhospital[playerIndex] = 1;
				new->score -= 6;
				break;
			}
			
		}
	}
	
}

<<<<<<< HEAD
=======

// If a hunter encountered dracula, deduct their life points correspondingly
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
static void draculaEncounter(GameView new, int playerIndex)
{
    new->player_hp[playerIndex] -= 4;
    if (new->player_hp[playerIndex] < 0) new->player_hp[playerIndex] = 0;
	new->player_hp[PLAYER_DRACULA] -= 10;
	if (new->player_hp[playerIndex] <= 0) {
		new->playerPlace[playerIndex] = ST_JOSEPH_AND_ST_MARY;
		new->inhospital[playerIndex] = 1;
		new->score -= 6;
	}
}

<<<<<<< HEAD
/*int railLengthCheck = -1;
static void hunterReachableRecursive(ConnList head, PlaceId *hunterReachable, Map new, int railLength, int j) {
    railLengthCheck++;
    if (railLengthCheck == railLength) return;
    ConnList curr = head;
    while (curr != NULL) {
        
            
        if (curr->type == RAIL) {
            hunterReachable[j] = curr->p;
            j++;
        
            ConnList newHead = MapGetConnections(new, curr->p);
            hunterReachableRecursive(newHead, hunterReachable, new, railLength, j);
        }
        curr = curr->next;
        railLengthCheck = 0;
    }
}*/


=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4

// Queue.c ... list implementation of a queue

// private function for creating list nodes
<<<<<<< HEAD
static ConnList createNode (Item item)
{
	ConnList n = malloc (sizeof (ConnList));
=======
static ConnList createNode(Item item)
{
	ConnList n = malloc(sizeof(ConnList));
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	assert (n != NULL);
	n->p = item;
	n->next = NULL;
	return n;
<<<<<<< HEAD
}

// create an initially empty Queue
Queue createQueue (void)
{
	Queue q = malloc (sizeof (struct QueueRep));
	assert (q != NULL);
	q->head = NULL;
	q->tail = NULL;
	q->size = 0;
	return q;
}

// free all memory used by the Queue
void dropQueue (Queue q)
{
	ConnList curr;
	ConnList next;
	assert (q != NULL);
	curr = q->head;
	while (curr != NULL) {
		next = curr->next;
		curr = next;
	}
	free (q);
}

// add new Item to the tail of the Queue
void enterQueue (Queue q, Item it)
{
	assert (q != NULL);
	ConnList n = createNode (it);
=======
}

// create an initially empty Queue
Queue createQueue(void)
{
	Queue q = malloc(sizeof(struct QueueRep));
	assert (q != NULL);
	q->head = NULL;
	q->tail = NULL;
	return q;
}

// free all memory used by the Queue
void dropQueue(Queue q)
{
	ConnList curr;
	ConnList next;
	assert(q != NULL);
	curr = q->head;
	while (curr != NULL) {
		next = curr->next;
		curr = next;
	}
	free (q);
}

// add new Item to the tail of the Queue
void enterQueue (Queue q, Item it)
{
	assert(q != NULL);
	ConnList n = createNode(it);
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	if (q->head == NULL) {
		q->head = n;
	} else {
	    q->tail->next = n;
	}
	q->tail = n;
<<<<<<< HEAD
	q->size++;
=======
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
}

// remove Item from head of Queue; return it
Item leaveQueue (Queue q)
{
<<<<<<< HEAD
	assert (q != NULL);
	Item it = q->head->p;
	ConnList delNode = q->head;
	q->head = q->head->next;
	free (delNode);
	q->size--;
=======
	assert(q != NULL);
	Item it = q->head->p;
	ConnList delNode = q->head;
	q->head = q->head->next;
	free(delNode);
>>>>>>> 02f5d0f22e8a50cdb9236642da210ecbf5e952d4
	return it;
}



